(doc first)
(doc rest)
(let [[first rest] [1 2 3 4 5 6]
  (println first " + " (count rest)))
  (println first " + " (count rest))=
(def sum [coll]
  (if (empty? coll)
    0
    (+ (first coll)
       (sum (rest coll)))))
(defn sum [coll] (if (empty? coll) 0 (+ (first coll) (sum (rest coll)))))
(sum [1 2 3 4])
(use 'recursion :reload-all)
(product 3)
(use 'recursion :reload-all)
(product 3)
(product [1 2 3])
(product [1 2 3 4])
(product [])
(product [0 1 2])
(product #{2 3 4})
(use 'recursion :reload-all)
(singleton? [1])
(singleton? #{2})
(singleton? [])
(singleton? [1 2 3])
(use 'recursion :reload-all)
(my-last [])
(use 'recursion :reload-all)
(my-last [])
(my-last [1 2 3])
(my-last [2 5])
(use 'recursion :reload-all)
(max-element [2 4 1 4]
)
(max-element [2])
(max-element [])
(use 'recursion :reload-all)
(seq-max [1] [1 2])
(seq-max [1 2] [2 3])
(seq-max [1 2] [3 4])
(use 'recursion :reload-all)
(longest-sequence [[1 2] [] [1 2 3]])
(longest-sequence [[1 2]])
(longest-sequence [])
(cons [] [1 2 3])
(concat [] [1 2 3])
(use 'recursion :reload-all)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-filter odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-filter odd? [1 2 3 4])
(my-filter (fn [x] (> x 9000)) [12 49 90 9001 10000])
(my-filter even? [1 3 5 7])
(use 'recursion :reload-all)
(sequence-contains? 3 [1 2 3])
(use 'recursion :reload-all)
(sequence-contains? 3 [1 2 3])
(sequence-contains? :pony [])
(sequence-contains? 3 [4 7 9])
(use 'recursion :reload-all)
(my-take-while odd? [1 2 3 4])
(my-take-while odd? [1 3 4 5])
(my-take-while even? [1 3 4 5])
(my-take-while odd? [])
(use 'recursion :reload-all)
(my-drop-while odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-drop-while odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-drop-while odd? [1 2 3 4])
(use 'recursion :reload-all)
(my-drop-while odd? [1 2 3 4])
(my-drop-while odd? [1 3 4 5])
(my-drop-while even? [1 3 4 5])
(my-drop-while odd? [])
(= [] [])
(use 'recursion :reload-all)
(seq= [1 2 4] '(1 2 4))
(seq= [1 2 3] [1 2 3])
(seq= [1 2 3] [1 2 3 4])
(seq= [1 3 5] [])
(use 'recursion :reload-all)
(my-map + [1 2 3] [4 4 4])
(use 'recursion :reload-all)
(my-map + [1 2 3] [4 4 4])
(my-map + [1 2 3 4] [0 0 0])
(my-map + [1 2 3] [])
(vector 1 2)
(apply vector [1 2 3])
(map vector [1 2 3] [:a :b :c])
(defn indexed [a-seq]
  (let [indexes (range 0 (count a-seq))]
    (map vector indexes a-seq)))
(indexed [:a :b :c])
(den consecutives [a-seq] (map vector a-seq (rest a-seq)))
(defn consecutives [a-seq] (map vector a-seq (rest a-seq)))
(consecutives [:a :b :c])
(consecutives [1 2 3 4])
(defn factorial [n]
  (if (zero? n)
    1
    (* n (factorial (dec n)))))
(factorial 5)
(factorial 6)
(factorial 7)
(factorial 8)
(map factorial (range 1 11))
(map factorial (range 1 20))
(use 'recursion :reload-all)
(power 2 3)
(power 2 4)
(power 5 0)
(poweer 3 -1)
(power 3 -1)
(map fib (range 1 11))
(use 'recursion :reload-all)
(fib 1)
(fib 0)
(fib 2)
(fib 1)
(use 'recursion :reload-all)
(fib 5)
(map fib (range 1 21))
(map fib (range 0 21))
(use 'recursion :reload-all)
(fib 0)
(fib 1)
(fib 2)
(map fib (range 1 21))
(my-repeat 5 1)
(use 'recursion :reload-all)
(my-repeat 5 1)
(use 'recursion :reload-all)
(my-repeat 5 1)
(my-repeat 5 :a)
(my-repeat 5 "a")
(my-repeat -1 :a)
(use 'recursion :reload-all)
(my-range 0)
(my-range 1)
(my-range 2)
(my-range 3)
(my-range 4)
(use 'recursion :reload-all)
(tails [1 2 3 4])
(map rest [1 2 3 4])
(map rest '(1 2 3 4))
(use 'recursion :reload-all)
(tails [1 2 3 4])
(use 'recursion :reload-all)
(tails [1 2 3 4])
(tails '(1 2 3 4))
(tails #{1 2 3 4})
(use 'recursion :reload-all)
(inits [1 2 3 4])
(use 'recursion :reload-all)
(inits [1 2 3 4])
(use 'recursion :reload-all)
(tails [1 2 3 4])
(cons 1 2 3 [])
(cons 1 ())
(use 'recursion :reload-all)
(tails [1 2 3 4])
(use 'recursion :reload-all)
(tails [1 2 3 4]
)
(inits [1 2 3 4])
(use 'recursion :reload-all)
(inits [1 2 3 4])
(my-range 2)
(use 'recursion :reload-all)
(my-range 2)
(my-range 0)
(use 'recursion :reload-all)
(my-range 0)
(my-range 1)
(my-range 2)
(my-range 3)
(use 'recursion :reload-all)
(my-range 0)
(use 'recursion :reload-all)
(my-range 0)
(my-range 1)
(my-range 2)
(my-range 3)
(def myarr [1 2 3])
(concat (rest myarr) (first myarr))
(concat (rest myarr) [(first myarr)])
(init [1 2 3])
(my-last [1 2 3])
(concat (rest (myarr) [(first myarr])))
(concat (rest myarr) [(first myarr)])
(concat '(1 2 3) ())
(concat [1 2 3] [])
(concat [1 2 3] [()])
(concat [1 2 3] 1)
(cons 1 [1 2 3])
(use 'recursion :reload-all)
(rotations [1 2 3])
(rotation [1 2])
(rotations [])
(defn rotate [seq] (concat (rest seq) ((first seq))))
(defn rot [seq] (concat (rest seq) ((first seq))))
(rot [1 2 3])
(rest [1 2 3])
(first [1 2 3])
(concat (rest [1 2 3]) ((first [1 2 3])))
(rest [1])
(first [1])
(rest [])
(first [])
(use 'recursion :reload-all)
(rotate [1 2 3])
(use 'recursion :reload-all)
(rotate [1 2 3])
(concat '(2 3) '(1))
(mylist [1 2 3])
(def mylist [1 2 3])
mylist
(concat (rest mylist) (first mylist))
(concat (rest mylist) ((first mylist)))
(concat (rest mylist) '((first mylist)))
(concat (rest mylist) ((first mylist)))
(concat (rest mylist) [(first mylist]))
(concat (rest mylist) [(first mylist)])
(rotate [1 2 3])
(rotate [])
(concat [1] [2] [3])
(cons (rotate [1 2 3]) [])
(cons (rotate [1 2 3]) '())
(cons (rotate (2 3 1) (cons (rotate (1 2 3)) [])))
(def l1 (cons (rotate [1 2 3])))
(def l1 (cons (rotate [1 2 3]) []))
l1
(cons (rotate (2 3 1) l1)
)
(cons (rotate (2 3 1) l1))
(cons (1 2 3) (()))
(cons (1 2 3) ())
(cons (1 2 3) [])
(cons 1 [])
(cons (1 2 3) [[]])
(cons [1 2 3] [[]])
(cons [1 2 3] [])
(cons [4 5 6] (cons [1 2 3] []))
(cons 1 (1 2 3))
(cons 1 '(1 2 3))
(cons '(1 2 3) '())
(def l1 (cons (rotate [1 2 3]) []))
l1
(cons (rotate [2 3 1]) l1)
(def l2 (cons (rotae 2 3 1) l1))
(def l2 (cons (rotate [2 3 1]) l1))
l2
(def l3 (cons (rotate [3 1 2]) l2))
l3
(cons '() l3)
(inits [1 2 3])
(tails (1 2 3))
(tails '(1 2 3))
(inits [1 2 3])
(tails [1 2 3])
(inits [1 2 3])
(tails [1 2 3])
(inits [1 2 3])
(tails [1 2 3])
(tails (reverse [1 2 3]))
(inits [1 2 3])
(tails (reverse [1 2 3])
)
(inits (reverse [1 2 3])
)
(reverse (inits [1 2 3]))
(inits (reverse [1 2 3]))
(tails [1 2 3])
(def i (inits [1 2 3]))
(def t (tails [1 2 3]))
inits
i
t
(def ri (reverse (inits [1 2 3])))
ri
(def rt (reverse (tails [1 2 3])))
rt
(map concat ri rt)
(map concat rt ri)
(use 'recursions :reload-all)
(use 'recursion :reload-all)
(rotations [a b])
(rotation [:a :b])
(rotations [:a :b])
(reverse (inits [:a :b]))
(reverse (tails [:a :b]))
(def mylist1 [1 2 3])
(def mylist2 [:a :b])
(def mylist3 [1 5 9 2])
(defn rotations [a-seq] (rest (map concat (reverse (tails a-seq)) (reverse (inits my-seq)))))
(defn my-rot [a-seq]
  (rest
    (map concat
       (reverse (tails a-seq)) (reverse (inits a-seq))))))
(use 'recursion :reload-all)
(rotations [1 2 3])
(rotations [1 5 9 2])
(defn count-elem-helper [n elem coll]
  (if empty? coll)
    n
    (let [new-count (if (= elem (first coll)) (inc n) n)]
      (count-elem-helper new-count elem (rest coll)))))
(defn count-elem-helper [n elem coll]
  (if (empty? coll)
    n
    (let [new-count (if (= elem (first coll))
                      (inc n)
                      n)]
      (count-elem-helper new-count
                         elem
                         (rest coll)))))
(defn count-elem [elem coll]
  (count-elem-helper 0 elem coll))
(count-elem 5 (range 1 11))
(count-elem 1 [1 0 1 0 1 0 1 0 1 1 0 0 1 0 0 1])
(def mymap {:a 3 :b 5})
(:a mymap)
(assoc mymap :a (+ (:a mymap) 1))
(assoc mymap :c (+ (:c mymap) 1))
(contains? mymap :a)
(first [])
(rest [])
(use 'recursion :reload-all)
(my-freuqencies [:a :b :c :a :c :d :d :d :a])
(def mylist [:a :b :c :c :c :d :d :d :d :a :c])
(my-frequencies mylist)
(def mymap {:a 2 :b 3 :c 2})
(first mymap)
(get (first mymap) :a)
(get (first mymap) 1)
(let [[key val] (first mymap)]
  (println "key: " key " val: " val))
(rest mymap)
(concat [1 2 2] [])
(repeat 5 1)
(use 'recursion :reload-all)
(un-freuqencies {:a 2 :b 5})
(un-frequencies {:a 2 :b 5})
(un-frequencies {:a 3 :b 2 "^_^" 1})
(un-frequencies (my-frequencies [:a :b :c :a]))
(my-frequencies (un-frequencies {:a 100 :b 10})
)
(use 'recursion :reload-all)
(my-take 2 [1 2 3 4])
(use 'recursion :reload-all)
(my-take 2 [1 2 3 4])
(my-take 4 [:a :b])
(my-take 0 [:a :b])
(use 'recursion :reload-all)
(my-drop 2 [1 2 3 4])
(use 'recursion :reload-all)
(my-drop 2 [1 2 3 4])
(use 'recursion :reload-all)
(my-drop 2 [1 2 3 4])
(my-drop 4 [:a :b])
(use 'recursion :reload-all)
(my-drop 4 [:a :b])
(use 'recursion :reload-all)
(halve [1 2 3 4])
(def mylist [1 2 3 4])
(use 'recursion :reload-all)
(halve [1 2 3 4])
(vector 1 2)
(halve mylist)
(my-drop
q
(my-drop 2 [1 2 3 4])
(my-take 2 [1 2 3 4])
(vector (my-take 2 [1 2 3 4]) (my-drop 2 [1 2 3 4]))
(vector (my-take 3 [1 2 3 4 5] (my-drop 3 [1 2 3 4 5])))
(vector (my-take 3 [1 2 3 4 5]) (my-drop 3 [1 2 3 4 5]))
(int (/ (count [1 2 3 4 5]) 2))
(use 'recursion :reload-all)
(halve [1 2 3 4])
(halve [1 2 3 4 5])
(halve [1])
(use 'recursion :reload-all)
(halve [1])
(use 'recursion :reload-all)
(halve [1])
(< 1 nil)
(< nil)
(< nil 1)
(empty? nil)
(rest [])
(rest (rest []))
(concat 1 [1 2])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(concat (vector 1) [1 2 3 4 5])
(seq-merge [4] [1 2 6 7])
(concat (vector 1) [1 2 3 4 5])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(cons 1 [1 2 3 4])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(cons 1 '())
quit
(use 'recursion :reload-all)
(seq-merge [4] [1 2 6 7])
(seq-merge [1 5 7 9] [2 2 8 10])
(use 'recursion :reload-all)
(merge-sort [])
(merge-sort [1 2 3])
(merge-sort [5 3 4 17 2 100 1])
